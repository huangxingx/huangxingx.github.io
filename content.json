{"meta":{"title":"huangxingx","subtitle":"Follow Your Heart.","description":null,"author":"huangxingx","url":"https://huangxingx.github.io","root":"/"},"pages":[],"posts":[{"title":"Java双亲委派机制及用法","slug":"java/java双亲委派机制及用法","date":"2022-11-02T16:00:00.000Z","updated":"2022-11-03T03:24:00.607Z","comments":true,"path":"2022/11/03/java/java双亲委派机制及用法/","link":"","permalink":"https://huangxingx.github.io/2022/11/03/java/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%94%A8%E6%B3%95/","excerpt":"","text":"Java双亲委派机制及用法一、JVM类加载过程整个生命周期包括如下7个阶段 加载(loading)也称为装载 验证、准备、解析3个部分统称为链接(Linking) 初始化 使用 销毁 二、类加载器介绍JVM中有内置了三个初始的类加载器。 **BootstrapClassLoader(引导类、启动类加载器)**，顶层类加载器，C++实现。加载%JAVA_HOME%lib目录下jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类，加载java.*。 ExtensionClassLoader(扩展类加载器) ：负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :加载当前应用classpath下的所有jar包和类（在spring加载中起到了重要作用）。 三、双亲委派模型一个类加载的时候先交由父类加载器去加载，如果父类加载器也存在父类加载器，继续交由父类加载，以此递归，如果父类加载无法加载再由自己去加载。 如果想打破双亲委派机制可以自定义一个类加载器继承java.lang.ClassLoader，重写loadClass方法，不交由父类去加载。 如果只是想自定义加载class的方法，比如读取二进制流后进行解密等。只需要重写findClass就行了。 loadClass方法负责加载流程，findClass方法负责具体加载细节。 四、双亲委派模式的特点 避免重复加载class，保证数据安全。 保护核心class无法修改。 不同加载器加载同一个class不是同一个class对象，保证class执行安全。","categories":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/tags/java/"}]},{"title":"Arthas","slug":"java/arthas","date":"2022-11-02T16:00:00.000Z","updated":"2022-11-03T11:58:30.052Z","comments":true,"path":"2022/11/03/java/arthas/","link":"","permalink":"https://huangxingx.github.io/2022/11/03/java/arthas/","excerpt":"","text":"Arthas快速入门文档地址：https://arthas.aliyun.com/ 下载并启动arthas curl -O https://arthas.aliyun.com/arthas-boot.jar java -jar arthas-boot.jar 使用as.sh Arthas 支持在 Linux/Unix/Mac 等平台上一键安装，请复制以下内容，并粘贴到命令行中，敲 回车 执行即可： curl -L https://arthas.aliyun.com/install.sh | sh 常用命令logger更新 logger lever logger --name ROOT --level debug jad反编译指定已加载类的源码 使用参考 https://arthas.aliyun.com/doc/jad.html 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 [c:] 类所属 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [E] 开启正则表达式匹配，默认为通配符匹配 tt方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测 tt -t demo.MathGame primeFactors 表格字段说明 表格字段 字段解释 INDEX 时间片段记录编号，每一个编号代表着一次调用，后续 tt 还有很多命令都是基于此编号指定记录操作，非常重要。 TIMESTAMP 方法执行的本机时间，记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的hashCode()，注意，曾经有人误认为是对象在 JVM 中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 tracetrace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [n:] 命令执行次数 #cost 方法执行耗时 trace demo.MathGame run -n 10 &#39;#cost &gt; 10&#39; watch让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 函数名表达式匹配 express 观察表达式，默认值：&#123;params, target, returnObj&#125; condition-express 条件表达式 [b] 在函数调用之前观察 [e] 在函数异常之后观察 [s] 在函数返回之后观察 [f] 在函数结束之后(正常返回和异常返回)观察 [E] 开启正则表达式匹配，默认为通配符匹配 [x:] 指定输出结果的属性遍历深度，默认为 1，最大值是 4 watch demo.MathGame primeFactors -x 2 dashboard当运行在 Ali-tomcat 时，会显示当前 tomcat 的实时信息，如 HTTP 请求的 qps, rt, 错误数, 线程池信息等等。 参数说明 参数名称 参数说明 [i:] 刷新实时数据的时间间隔 (ms)，默认 5000ms [n:] 刷新实时数据的次数","categories":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/tags/java/"}]},{"title":"git config","slug":"git/git-config","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T02:58:42.349Z","comments":true,"path":"2022/11/01/git/git-config/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/git/git-config/","excerpt":"","text":"git config官方文档地址：https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE自定义 Git - 配置 Git: https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git 用户信息安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： $ git config --global user.name &quot;Joemuhuang&quot; $ git config --global user.email &quot;Joemuhuang@tencent.com` 查看不同级别的配置文件#查看系统config git config --system --list #查看当前用户（global）配置 git config --global --list #查看当前仓库配置信息 git config --local --list 检查配置信息git config --list 生成 sshkeyssh-keygen -t rsa -C &quot;youxiang@tencent.com&quot; 验证和修改ssh -T git@github.com","categories":[{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/tags/git/"}]},{"title":"docker 常用命令","slug":"docker/docker-常用命令","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T03:00:04.096Z","comments":true,"path":"2022/11/01/docker/docker-常用命令/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/docker/docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"docker 常用命令镜像导入导出导出docker save imageid &gt; filename.tar imagesname 举例 docker save 4e8c7ea9f913 &gt; pulsar-manager_0.2.0.tar apachepulsar/pulsar-manager 导入docker load [OPTIONS] OPTIONS 说明： –input , -i : 指定导入的文件，代替 STDIN。–quiet , -q : 精简输出信息。","categories":[{"name":"docker","slug":"docker","permalink":"https://huangxingx.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://huangxingx.github.io/tags/docker/"}]},{"title":"git 统计命令","slug":"git/git-统计命令","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T02:55:47.605Z","comments":true,"path":"2022/11/01/git/git-统计命令/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/git/git-%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Git 统计命令统计某人的代码提交量，包括增加，删除git log --author=&quot;$(git config --get user.name)&quot; --pretty=tformat: --numstat | gawk &#39;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\\n&quot;,add,subs,loc &#125;&#39; 仓库提交者排名前 5（如果看全部，去掉 head 管道即可）git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5 仓库提交者（邮箱）排名前 5：这个统计可能不会太准，因为很多人有不同的邮箱，但会使用相同的名字git log --pretty=format:%ae | gawk -- &#39;&#123; ++c[$0]; &#125; END &#123; for(cc in c) printf &quot;%5d %s\\n&quot;,c[cc],cc; &#125;&#39; | sort -u -n -r | head -n 5 贡献者统计：git log --pretty=&#39;%aN&#39; | sort -u | wc -l 提交数统计：git log --oneline | wc -l 添加或修改的代码行数：git log --stat|perl -ne &#39;END &#123; print $c &#125; $c += $1 if /(\\d+) insertions/&#39; git log 参数说明：--author 指定作者 --stat 显示每次更新的文件修改统计信息，会列出具体文件列表 --shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表： --numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表： -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 例如：git log -p -2 --name-only 仅在提交信息后显示已修改的文件清单 --name-status 显示新增、修改、删除的文件清单 --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”） --graph 显示 ASCII 图形表示的分支合并历史 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式） 例如： git log --pretty=oneline ; git log --pretty=short ; git log --pretty=full ; git log --pretty=fuller --pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析 例如：git log --pretty=format:&quot;&quot;%h - %an, %ar : %s&quot;&quot; 下面列出了常用的格式占位符写法及其代表的意义。 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 --since 限制显示输出的范围， 例如： git log --since=2.weeks 显示最近两周的提交 选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。 一些例子： git log --until=1.minute.ago // 一分钟之前的所有 log git log --since=1.day.ago //一天之内的log git log --since=1.hour.ago //一个小时之内的 log git log --since=`.month.ago --until=2.weeks.ago //一个月之前到半个月之前的log git log --since ==2013-08.01 --until=2013-09-07 //某个时间段的 log git blame看看某一个文件的相关历史记录例如： git blame index.html --date short","categories":[{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/tags/git/"}]},{"title":"gin 验证器","slug":"golang/gin 验证器","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T03:05:14.547Z","comments":true,"path":"2022/11/01/golang/gin 验证器/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/golang/gin%20%E9%AA%8C%E8%AF%81%E5%99%A8/","excerpt":"","text":"[toc] 前言gin的验证器底层使用的是 validator 库实现的，故gin验证器可以使用validator库中的所有功能 所有标签 翻译器 自定义校验器 其他（不一一列举） 不同的是gin使用的Tag 为 binding，而validator库使用的是 validate；gin中在初始化validate时通过validate.SetTagName(“binding”)设置标签 func (v *defaultValidator) lazyinit() &#123; v.once.Do(func() &#123; v.validate = validator.New() v.validate.SetTagName(&quot;binding&quot;) &#125;) &#125; 本文中 gin 版本为 v1.6.3, validator版本为 v10 gin validator validator 库字段gin 使用时把 validate tag 改为 binding 即可 字段 描述 例子 required 必填 Field或Struct validate:”required” omitempty 空时忽略 Field或Struct validate:”omitempty” len 长度 Field validate:”len=0” eq 等于 Field validate:”eq=0” gt 大于 Field validate:”gt=0” gte 大于等于 Field validate:”gte=0” lt 小于 Field validate:”lt=0” lte 小于等于 Field validate:”lte=0” eqfield 同一结构体字段相等 Field validate:”eqfield=Field2” nefield 同一结构体字段不相等 Field validate:”nefield=Field2” gtfield 大于同一结构体字段 Field validate:”gtfield=Field2” gtefield 大于等于同一结构体字段 Field validate:”gtefield=Field2” ltfield 小于同一结构体字段 Field validate:”ltfield=Field2” ltefield 小于等于同一结构体字段 Field validate:”ltefield=Field2” eqcsfield 跨不同结构体字段相等 Struct1.Field validate:”eqcsfield=Struct2.Field2” necsfield 跨不同结构体字段不相等 Struct1.Field validate:”necsfield=Struct2.Field2” gtcsfield 大于跨不同结构体字段 Struct1.Field validate:”gtcsfield=Struct2.Field2” gtecsfield 大于等于跨不同结构体字段 Struct1.Field validate:”gtecsfield=Struct2.Field2” ltcsfield 小于跨不同结构体字段 Struct1.Field validate:”ltcsfield=Struct2.Field2” ltecsfield 小于等于跨不同结构体字段 Struct1.Field validate:”ltecsfield=Struct2.Field2” min 最大值 Field validate:”min=1” max 最小值 Field validate:”max=2” structonly 仅验证结构体，不验证任何结构体字段 Struct validate:”structonly” nostructlevel 不运行任何结构级别的验证 Struct validate:”nostructlevel” dive 向下延伸验证，多层向下需要多个dive标记 [][]string validate:”gt=0,dive,len=1,dive,required” dive Keys&amp; EndKeys 与dive同时使用，用于对map对象的键的和值的验证，keys为键，endkeys为值 map[string]string validate :”gt=0,dive,keys,eq=1 required_with 其他字段其中一个不为空且当前字段不为空 Field validate:”required_with=Field1 Field2” required_with_all 其他所有字段不为空且当前字段不为空 Field validate:”required_with_all=Field1 Field2” required_without 其他字段其中一个为空且当前字段不为空 Field `validate:”required_without=Field1 Field2” required_without_all 其他所有字段为空且当前字段不为空 Field validate:”required_without_all=Field1 Field2” isdefault 是默认值 Field validate:”isdefault=0” oneof 其中之一 Field validate:”oneof=5 7 9” containsfield 字段包含另一个字段 Field validate:”containsfield=Field2” excludesfield 字段不包含另一个字段 Field validate:”excludesfield=Field2” unique 是否唯一，通常用于切片或结构体 Field validate:”unique” alphanum 字符串值是否只包含 ASCII 字母数字字符 Field validate:”alphanum” alphaunicode 字符串值是否只包含 unicode 字符 Field validate:”alphaunicode” alphanumunicode 字符串值是否只包含 unicode 字母数字字符 Field validate:”alphanumunicode” numeric 字符串值是否包含基本的数值 Field validate:”numeric” hexadecimal 字符串值是否包含有效的十六进制 Field validate:”hexadecimal” hexcolor 字符串值是否包含有效的十六进制颜色 Field validate:”hexcolor” lowercase 符串值是否只包含小写字符 Field validate:”lowercase” uppercase 符串值是否只包含大写字符 Field validate:”uppercase” email 字符串值包含一个有效的电子邮件 Field validate:”email” json 字符串值是否为有效的 JSON Field validate:”json” file 符串值是否包含有效的文件路径，以及该文件是否存在于计算机上 Field validate:”file” url 符串值是否包含有效的 url Field validate:”url” uri 符串值是否包含有效的 uri Field validate:”uri” base64 字符串值是否包含有效的 base64值 Field validate:”base64” contains 字符串值包含子字符串值 Field validate:”contains=@” containsany 字符串值包含子字符串值中的任何字符 Field validate:”containsany=abc” containsrune 字符串值包含提供的特殊符号值 Field validate:”containsrune=☢” excludes 字符串值不包含子字符串值 Field validate:”excludes=@” excludesall 字符串值不包含任何子字符串值 Field validate:”excludesall=abc” excludesrune 字符串值不包含提供的特殊符号值 Field validate:”containsrune=☢” startswith 字符串以提供的字符串值开始 Field validate:”startswith=abc” endswith 字符串以提供的字符串值结束 Field validate:”endswith=abc” ip 字符串值是否包含有效的 IP 地址 Field validate:”ip” ipv4 字符串值是否包含有效的 ipv4地址 Field validate:”ipv4” datetime 字符串值是否包含有效的 日期 Field validate:”datetime” 常用验证Tagtype Test struct &#123; ID int `binding:&quot;required&quot;` //数字确保不为0 Name string `binding:&quot;required,min=1,max=8&quot;` //字符串确保不为&quot;&quot;，且长度 &gt;=1 &amp;&amp; &lt;=8 （min=1,max=8等于gt=0,lt=9） Value string `binding:&quot;required,gte=1,lte=8&quot;` //字符串确保不为&quot;&quot;，且长度 &gt;=1 &amp;&amp; &lt;=8 Status int `binding:&quot;min=1,max=10&quot;` //最小为0，最大为10（min=0,max=10等于gt=0,lt=11） PhoneNumber string `binding:&quot;required,len=11&quot;` //不为&quot;&quot;且长度为11 Time string `binding:&quot;datetime=2006-01-02&quot;` //必须如2006-01-02的datetime格式 Color string `binding:&quot;oneof=red green&quot;` //是能是red或者green Size int `binding:&quot;oneof=37 39 41&quot;` //是能是37或者39或者41 Email string `binding:&quot;email&quot;` //必须邮件格式 JSON string `binding:&quot;json&quot;` //必须json格式 URL string `binding:&quot;url&quot;` //必须url格式 UUID string `binding:&quot;uuid&quot;` //必须uuid格式 &#125; 自定义验证器1package main import ( &quot;fmt&quot; &quot;net/http&quot; &quot;time&quot; &quot;github.com/go-playground/validator/v10&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/gin-gonic/gin/binding&quot; ) // Booking contains binded and validated data. type Booking struct &#123; CheckIn time.Time `form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;` CheckOut time.Time `form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn&quot; time_format:&quot;2006-01-02&quot;` &#125; //validator v9以上写法 func bookableDate(fl validator.FieldLevel) bool &#123; if date, ok := fl.Field().Interface().(time.Time); ok &#123; today := time.Now() fmt.Println(&quot;date:&quot;, date) if date.Unix() &gt; today.Unix() &#123; fmt.Println(&quot;date unix ：&quot;, date.Unix()) return true &#125; &#125; return false &#125; //validator v8写法 //func bookableDate( // v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, // field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string, //) bool &#123; // if date, ok := field.Interface().(time.Time); ok &#123; // today := time.Now() // if date.Unix()&gt;today.Unix()&#123; // return true // &#125; // &#125; // return false //&#125; func main() &#123; route := gin.Default() if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123; _ = v.RegisterValidation(&quot;bookabledate&quot;, bookableDate) &#125; route.GET(&quot;/bookable&quot;, getBookable) route.Run() &#125; func getBookable(c *gin.Context) &#123; var b Booking if err := c.ShouldBindWith(&amp;b, binding.Query); err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;) &#125; else &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;ok&quot;, &quot;booking&quot;: b&#125;) &#125; &#125; 验证器自定义错误信息1原有的错误信息如下： &#123; &quot;message&quot;: &quot;Key: &#39;LoginRequest.Mobile&#39; Error:Field validation for &#39;Mobile&#39; failed on the &#39;required&#39; tag\\nKey: &#39;LoginRequest.Code&#39; Error:Field validation for &#39;Code&#39; failed on the &#39;required&#39; tag&quot; &#125; 这样的提示信息不是很友好, 在 validator 文档中也说明了这个信息只是用在开发时进行调试用的. 那么我们怎么返回自定义的验证提示呢. 参考 validator 文档, 我是这样来实现的. import ( &quot;gopkg.in/go-playground/validator.v8&quot; ) // 绑定模型 type LoginRequest struct &#123; Mobile string `form:&quot;mobile&quot; json:&quot;mobile&quot; binding:&quot;required&quot;` Code string `form:&quot;code&quot; json:&quot;code&quot; binding:&quot;required&quot;` &#125; // 绑定模型获取验证错误的方法 func (r *LoginRequest) GetError (err validator.ValidationErrors) string &#123; // 这里的 &quot;LoginRequest.Mobile&quot; 索引对应的是模型的名称和字段 if val, exist := err[&quot;LoginRequest.Mobile&quot;]; exist &#123; if val.Field == &quot;Mobile&quot; &#123; switch val.Tag&#123; case &quot;required&quot;: return &quot;请输入手机号码&quot; &#125; &#125; &#125; if val, exist := err[&quot;LoginRequest.Code&quot;]; exist &#123; if val.Field == &quot;Code&quot; &#123; switch val.Tag&#123; case &quot;required&quot;: return &quot;请输入验证码&quot; &#125; &#125; &#125; return &quot;参数错误&quot; &#125; 如何使用模型, 以登录方法为例 import ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot; &quot;gopkg.in/go-playground/validator.v8&quot; ) func Login(c *gin.Context) &#123; var loginRequest LoginRequest if err := c.ShouldBind(&amp;loginRequest); err == nil &#123; // 参数接收正确, 进行登录操作 c.JSON(http.StatusOK, loginRequest) &#125;else&#123; // 验证错误 c.JSON(http.StatusUnprocessableEntity, gin.H&#123; &quot;message&quot;: loginRequest.GetError(err.(validator.ValidationErrors)), // 注意这里要将 err 进行转换 &#125;) &#125; &#125; 验证器自定义错误信息2目录结构 . ├── main.go └── valid └── valid.go valid.valid.go package valid import ( &quot;fmt&quot; &quot;regexp&quot; &quot;strings&quot; &quot;github.com/gin-gonic/gin/binding&quot; &quot;github.com/go-playground/locales/zh&quot; ut &quot;github.com/go-playground/universal-translator&quot; &quot;github.com/go-playground/validator/v10&quot; zh_translations &quot;github.com/go-playground/validator/v10/translations/zh&quot; ) var v *validator.Validate var Trans ut.Translator // 初始化翻译器 func InitTrans() (err error) &#123; //修改gin框架中的Validator属性，实现自定制 if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123; //v.RegisterTagNameFunc(func(fld reflect.StructField) string &#123; // return fld.Tag.Get(&quot;comment&quot;) //field.Tag.Get(&quot;json&quot;) //&#125;) v.RegisterValidation(&quot;checkMobile&quot;, checkMobile) zhT := zh.New() //中文翻译器 // 第一个参数是备用（fallback）的语言环境 // 后面的参数是应该支持的语言环境（支持多个） // uni := ut.New(zhT, zhT) 也是可以的 uni := ut.New(zhT, zhT) var ok bool // 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找 Trans, ok = uni.GetTranslator(&quot;zh&quot;) if !ok &#123; return fmt.Errorf(&quot;uni.GetTranslator(%s) failed&quot;, &quot;zh&quot;) &#125; zh_translations.RegisterDefaultTranslations(v, Trans) // 添加额外翻译 _ = v.RegisterTranslation(&quot;checkMobile&quot;, Trans, func(ut ut.Translator) error &#123; return ut.Add(&quot;checkMobile&quot;, &quot;&#123;0&#125; 电话错误!&quot;, true) &#125;, func(ut ut.Translator, fe validator.FieldError) string &#123; t, _ := ut.T(&quot;checkMobile&quot;, fe.Field()) return t &#125;) &#125; return &#125; func checkMobile(fl validator.FieldLevel) bool &#123; ok, _ := regexp.MatchString(`^1[3-9][0-9]&#123;9&#125;$`, fl.Field().String()) return ok &#125; func ParseErr(errs validator.ValidationErrors) string &#123; var errList []string for _, e := range errs &#123; // can translate each error one at a time. errList = append(errList, e.Translate(Trans)) //errList = append(errList, e.Field()) &#125; return strings.Join(errList, &quot;|&quot;) &#125; main.go package main import ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/go-playground/validator/v10&quot; &quot;my-test/gin-validator/valid&quot; ) func main() &#123; route := gin.Default() _ = valid.InitTrans() route.POST(&quot;/valid&quot;, validHandler) route.Run() &#125; type req struct &#123; Name string `json:&quot;name&quot; binding:&quot;required&quot;` Mobile string `json:&quot;mobile&quot; binding:&quot;checkMobile&quot;` Age int `json:&quot;mobile&quot; binding:&quot;gt=12,lt=100&quot; comment:&quot;年龄大于12，小于100&quot;` &#125; func validHandler(c *gin.Context) &#123; req := req&#123;&#125; err := c.ShouldBindJSON(&amp;req) if err != nil &#123; errmsg := err.Error() if e, ok := err.(validator.ValidationErrors); ok &#123; errmsg = valid.ParseErr(e) &#125; c.JSON(http.StatusOK, gin.H&#123; &quot;error&quot;: errmsg, &#125;) return &#125; c.JSON(http.StatusOK, &quot;Success&quot;) &#125; 参考文档 gin - validator 参数校验 gin框架自定义验证错误提示信息 Golang使用validator进行数据校验及自定义翻译器 validator Go doc","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"gin","slug":"gin","permalink":"https://huangxingx.github.io/tags/gin/"}]},{"title":"golang 函数调用链","slug":"golang/golang 函数调用链","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T03:06:02.582Z","comments":true,"path":"2022/11/01/golang/golang 函数调用链/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/golang/golang%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE/","excerpt":"","text":"[TOC] 利用 defer 实现函数出入口的跟踪跟踪函数调用，我们首先想到的就是跟踪函数的出入口，而完成这一任务，当仁不让的就是利用defer func trace() func() &#123; pc, _, _, ok := runtime.Caller(1) if !ok &#123; panic(&quot;not found caller&quot;) &#125; fn := runtime.FuncForPC(pc) name := fn.Name() fmt.Printf(&quot;enter: %s\\n&quot;, name) return func() &#123; fmt.Printf(&quot;exit: %s\\n&quot;, name) &#125; &#125; func A1() &#123; defer trace()() B1() &#125; func B1() &#123; defer trace()() C1() &#125; func C1() &#123; defer trace()() D() &#125; func D() &#123; defer trace()() &#125; func main() &#123; A1() &#125; 我们看到：以 A1 实现为例，当执行流来带 defer 语句时，首先会对 defer 后面的表达式进行求值。trace 函数会执行，输出函数入口信息，并返回一个 “打印出口信息” 的匿名函数。该函数在此并不会执行，而是被注册到函数 A1 的 defer 函数栈中，待 A1 函数执行结束后才会被弹出执行。也就是在 A1 结束后，会有一条函数的出口信息被输出 $go build $./functrace-demo enter: main.A1 enter: main.B1 enter: main.C1 enter: main.D exit: main.D exit: main.C1 exit: main.B1 exit: main.A1","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"}]},{"title":"golang 正则表达式常用","slug":"golang/golang 正则表达式常用","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T03:06:50.461Z","comments":true,"path":"2022/11/01/golang/golang 正则表达式常用/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/golang/golang%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E7%94%A8/","excerpt":"","text":"regex_const.gopackage check import ( &quot;regexp&quot; )s const ( // 中国大陆手机号码正则匹配, 不是那么太精细 // 只要是 13,14,15,17,18,19 开头的 11 位数字就认为是中国手机号 chinaMobilePattern = `^1[0-9]&#123;10&#125;$` // 用户昵称的正则匹配, 合法的字符有 0-9, A-Z, a-z, _, 汉字 // 字符 &#39;_&#39; 只能出现在中间且不能重复, 如 &quot;__&quot; nicknamePattern = `^[a-z0-9A-Z\\p&#123;Han&#125;]+(_[a-z0-9A-Z\\p&#123;Han&#125;]+)*?$` // 用户名的正则匹配, 合法的字符有 0-9, A-Z, a-z, _ // 第一个字母不能为 _, 0-9 // 最后一个字母不能为 _, 且 _ 不能连续 usernamePattern = `^[a-zA-Z][a-z0-9A-Z]*(_[a-z0-9A-Z]+)*?$` // 电子邮箱的正则匹配, 考虑到各个网站的 mail 要求不一样, 这里匹配比较宽松 // 邮箱用户名可以包含 0-9, A-Z, a-z, -, _, . // 开头字母不能是 -, _, . // 结尾字母不能是 -, _, . // -, _, . 这三个连接字母任意两个不能连续, 如不能出现 --, __, .., -_, -., _. // 邮箱的域名可以包含 0-9, A-Z, a-z, - // 连接字符 - 只能出现在中间, 不能连续, 如不能 -- // 支持多级域名, x@y.z, x@y.z.w, x@x.y.z.w.e mailPattern = `^[a-z0-9A-Z]+([_\\-\\.][a-z0-9A-Z]+)*?@[a-z0-9A-Z]+([\\-\\.][a-z0-9A-Z]+)*?\\.[a-zA-Z]&#123;2,&#125;$` chineseNamePattern = &quot;^\\\\p&#123;Han&#125;+(\\u00B7\\\\p&#123;Han&#125;+)*?$&quot; chineseNameExPattern = &quot;^\\\\p&#123;Han&#125;+([\\u00B7\\u2022\\u2027\\u30FB\\u002E\\u0387\\u16EB\\u2219\\u22C5\\uFF65\\u05BC]\\\\p&#123;Han&#125;+)*?$&quot; ) var ( chinaMobileRegexp = regexp.MustCompile(chinaMobilePattern) nicknameRegexp = regexp.MustCompile(nicknamePattern) usernameRegexp = regexp.MustCompile(usernamePattern) mailRegexp = regexp.MustCompile(mailPattern) chineseNameRegexp = regexp.MustCompile(chineseNamePattern) chineseNameExRegexp = regexp.MustCompile(chineseNameExPattern) ) // 检验是否为合法的中国手机号, 不是那么太精细 // 只要是 13,14,15,18 开头的 11 位数字就认为是中国手机号 func IsChinaMobile(b []byte) bool &#123; if len(b) != 11 &#123; return false &#125; return chinaMobileRegexp.Match(b) &#125; // 同 func IsChinaMobile(b []byte) bool func IsChinaMobileString(s string) bool &#123; if len(s) != 11 &#123; return false &#125; return chinaMobileRegexp.MatchString(s) &#125; // 检验是否为合法的昵称, 合法的字符有 0-9, A-Z, a-z, _, 汉字 // 字符 &#39;_&#39; 只能出现在中间且不能重复, 如 &quot;__&quot; func IsNickname(b []byte) bool &#123; if len(b) == 0 &#123; return false &#125; return nicknameRegexp.Match(b) &#125; // 同 func IsNickname(b []byte) bool func IsNicknameString(s string) bool &#123; if len(s) == 0 &#123; return false &#125; return nicknameRegexp.MatchString(s) &#125; // 检验是否为合法的用户名, 合法的字符有 0-9, A-Z, a-z, _ // 第一个字母不能为 _, 0-9 // 最后一个字母不能为 _, 且 _ 不能连续 func IsUserName(b []byte) bool &#123; if len(b) == 0 &#123; return false &#125; return usernameRegexp.Match(b) &#125; // 同 func IsName(b []byte) bool func IsUserNameString(s string) bool &#123; if len(s) == 0 &#123; return false &#125; return usernameRegexp.MatchString(s) &#125; // 检验是否为合法的电子邮箱, 考虑到各个网站的 mail 要求不一样, 这里匹配比较宽松 // 邮箱用户名可以包含 0-9, A-Z, a-z, -, _, . // 开头字母不能是 -, _, . // 结尾字母不能是 -, _, . // -, _, . 这三个连接字母任意两个不能连续, 如不能出现 --, __, .., -_, -., _. // 邮箱的域名可以包含 0-9, A-Z, a-z, - // 连接字符 - 只能出现在中间, 不能连续, 如不能 -- // 支持多级域名, x@y.z, x@y.z.w, x@x.y.z.w.e func IsMail(b []byte) bool &#123; if len(b) &lt; 6 &#123; // x@x.xx return false &#125; return mailRegexp.Match(b) &#125; // 同 func IsMail(b []byte) bool func IsMailString(s string) bool &#123; if len(s) &lt; 6 &#123; // x@x.xx return false &#125; return mailRegexp.MatchString(s) &#125; // IsChineseName 检验是否为有效的中文姓名(比如 张三, 李四, 张三·李四) func IsChineseName(b []byte) bool &#123; return chineseNameRegexp.Match(b) &#125; // 同 IsChineseName(b []byte) bool func IsChineseNameString(s string) bool &#123; return chineseNameRegexp.MatchString(s) &#125; // IsChineseNameEx 检验是否为有效的中文姓名(比如 张三, 李四, 张三·李四), // 主要功能和 IsChineseName 相同, 但是如果姓名中包含不规范的间隔符, 会自动修正为正确的间隔符 &#39;\\u00B7&#39;, 并返回正确的结果. func IsChineseNameEx(b []byte) ([]byte, bool) &#123; if chineseNameRegexp.Match(b) &#123; return b, true &#125; if !chineseNameExRegexp.Match(b) &#123; return b, false &#125; list := []rune(string(b)) for i := 0; i &lt; len(list); i++ &#123; switch list[i] &#123; case &#39;\\u2022&#39;, &#39;\\u2027&#39;, &#39;\\u30FB&#39;, &#39;\\u002E&#39;, &#39;\\u0387&#39;, &#39;\\u16EB&#39;, &#39;\\u2219&#39;, &#39;\\u22C5&#39;, &#39;\\uFF65&#39;, &#39;\\u05BC&#39;: list[i] = &#39;\\u00B7&#39; &#125; &#125; return []byte(string(list)), true &#125; // 同 IsChineseNameEx(b []byte) ([]byte, bool) func IsChineseNameStringEx(s string) (string, bool) &#123; if chineseNameRegexp.MatchString(s) &#123; return s, true &#125; if !chineseNameExRegexp.MatchString(s) &#123; return s, false &#125; list := []rune(s) for i := 0; i &lt; len(list); i++ &#123; switch list[i] &#123; case &#39;\\u2022&#39;, &#39;\\u2027&#39;, &#39;\\u30FB&#39;, &#39;\\u002E&#39;, &#39;\\u0387&#39;, &#39;\\u16EB&#39;, &#39;\\u2219&#39;, &#39;\\u22C5&#39;, &#39;\\uFF65&#39;, &#39;\\u05BC&#39;: list[i] = &#39;\\u00B7&#39; &#125; &#125; return string(list), true &#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"regex","slug":"regex","permalink":"https://huangxingx.github.io/tags/regex/"}]},{"title":"mac zsh 终端","slug":"mac/mac-item2-终端","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T03:09:50.072Z","comments":true,"path":"2022/11/01/mac/mac-item2-终端/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/mac/mac-item2-%E7%BB%88%E7%AB%AF/","excerpt":"","text":"mac zsh 终端利用iTerm2+oh-my-zsh+Dracula主题打造我的Mac终端利器参考文章：https://blog.csdn.net/daiyuhe/article/details/88667875效果图 item2官网：https://www.iterm2.com/index.html oh-my-zsh配置安装oh-my-zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 在oh-my-zsh中启用插件plugins=( git zsh-autosuggestions zsh-syntax-highlighting mvn )","categories":[{"name":"mac","slug":"mac","permalink":"https://huangxingx.github.io/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://huangxingx.github.io/tags/mac/"}]},{"title":"ssh","slug":"linux/ssh","date":"2022-11-01T07:43:04.000Z","updated":"2022-11-01T03:00:59.190Z","comments":true,"path":"2022/11/01/linux/ssh/","link":"","permalink":"https://huangxingx.github.io/2022/11/01/linux/ssh/","excerpt":"","text":"ssh生成公钥ssh-keygen -t rsa -t 指定算法-f 指定生成秘钥路径-N 指定密码 拷贝公钥cd ~/.ssh scp id_rsa.pub root@B:/root/.ssh/authorized_keys #此命令在A机器执行，目的将公钥发送至B机器 scp id_rsa.pub root@A:/root/.ssh/authorized_keys #此命令在B机器执行，目的将公钥发送至B机器 将你的SSH公钥复制到远程主机，开启无密码登录 – 简单的方法 ssh-copy-id username@hostname 如果发现设置免密登陆，还需要输入密码，那么检查一下/root .ssh authorized_keys目录和文件的权限。 chmod 600 authorized_keys chmod 700 .ssh 如果authorized_keys文件、𝐻𝑂𝑀𝐸/.ssh 目录或HOME目录让本用户之外的用户有写权限，那么 sshd 都会拒绝使用 ~/.ssh/authorized_keys 文件中的key来进行认证的。","categories":[{"name":"linux","slug":"linux","permalink":"https://huangxingx.github.io/categories/linux/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://huangxingx.github.io/tags/ssh/"},{"name":"linux","slug":"linux","permalink":"https://huangxingx.github.io/tags/linux/"}]},{"title":"maven template","slug":"java/maven-template","date":"2021-11-01T16:00:00.000Z","updated":"2022-11-02T08:32:04.176Z","comments":true,"path":"2021/11/02/java/maven-template/","link":"","permalink":"https://huangxingx.github.io/2021/11/02/java/maven-template/","excerpt":"","text":"&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.11&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;spring-openfeign-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-openfeign-demo&lt;/name&gt; &lt;description&gt;spring-openfeign-demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;version&gt;2021.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redisson --&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;redisson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;!-- 是否开启发布版构件下载 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!-- 是否开启快照版构件下载 --&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;","categories":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://huangxingx.github.io/tags/maven/"}]},{"title":"java mapstruct 详解","slug":"java/java-mapstruct-详解","date":"2021-10-25T01:58:50.000Z","updated":"2022-11-02T08:31:55.892Z","comments":true,"path":"2021/10/25/java/java-mapstruct-详解/","link":"","permalink":"https://huangxingx.github.io/2021/10/25/java/java-mapstruct-%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"官网：https://mapstruct.org/ GitHub: https://github.com/mapstruct/mapstruct 关于 BeanUtil平时我经常使用Hutool中的BeanUtil类来实现对象转换，用多了之后就发现有些缺点： 对象属性映射使用反射来实现，性能比较低； 对于不同名称或不同类型的属性无法转换，还得单独写Getter、Setter方法； 对于嵌套的子对象也需要转换的情况，也得自行处理； 集合对象转换时，得使用循环，一个个拷贝。 对于这些不足，MapStruct都能解决，不愧为一款功能强大的对象映射工具！ IDEA插件支持 项目集成在SpingBoot中集成MapStruct非常简单，仅续添加如下两个依赖即可，这里使用的是1.4.2.Final版本 &lt;dependency&gt; &lt;!--MapStruct相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies","categories":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/tags/java/"},{"name":"mapstruct","slug":"mapstruct","permalink":"https://huangxingx.github.io/tags/mapstruct/"},{"name":"plugins","slug":"plugins","permalink":"https://huangxingx.github.io/tags/plugins/"}]},{"title":"golang 并发赋值安全性","slug":"golang/golang-并发赋值安全性","date":"2021-09-30T11:10:48.000Z","updated":"2022-11-01T02:42:47.276Z","comments":true,"path":"2021/09/30/golang/golang-并发赋值安全性/","link":"","permalink":"https://huangxingx.github.io/2021/09/30/golang/golang-%E5%B9%B6%E5%8F%91%E8%B5%8B%E5%80%BC%E5%AE%89%E5%85%A8%E6%80%A7/","excerpt":"","text":"Go 多协程并发的场景无处不在，并发对同一变量的赋值也是经常遇到。本文尝试探讨了 Go 中所有类型并发赋值的安全性。 由一条机器指令完成赋值的类型并发赋值是安全的，这些类型有：字节型，布尔型、整型、浮点型、字符型、指针、函数。 数组由一个或多个元素组成，大部分情况并发不安全。注意：当位宽不大于 64 位且是 2 的整数次幂（8，16，32，64），那么其并发赋值是安全的。 struct 或底层是 struct 的类型并发赋值大部分情况并发不安全，这些类型有：复数、字符串、 数组、切片、字典、通道、接口。注意：当 struct 赋值时退化为单个字段由一个机器指令完成赋值时，并发赋值又是安全的。这种情况有： 实部或虚部相同的复数的并发赋值；等长字符串的并发赋值；同长度同容量切片的并发赋值；同一种具体类型不同值并发赋给接口。","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"concurrent","slug":"concurrent","permalink":"https://huangxingx.github.io/tags/concurrent/"}]},{"title":"sync.Pool 对象池使用问题记录","slug":"golang/sync-Pool-对象池使用问题记录","date":"2021-09-30T03:07:11.000Z","updated":"2022-10-31T09:40:57.113Z","comments":true,"path":"2021/09/30/golang/sync-Pool-对象池使用问题记录/","link":"","permalink":"https://huangxingx.github.io/2021/09/30/golang/sync-Pool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"sync.Pool 对象重置问题 方式1: get -&gt; operate-obj -&gt; reset -&gt; put 问题：get 的对象在操作时可能没有被reset 到 方式2: get -&gt; reset -&gt; operate-obj -&gt; put 获取对象后，先 reset 在使用是没有问题的 gin 就是这样使用的 func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) &#123; c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() // 先reset engine.handleHTTPRequest(c) // 再使用 engine.pool.Put(c) // 使用之后直接 put &#125; cat test_syncpool.go package test import ( &quot;strconv&quot; &quot;sync&quot; &quot;testing&quot; ) type A struct &#123; Name string &#125; func (a *A) putValue(i int) &#123; a.Name = &quot;A+&quot; + strconv.Itoa(i) &#125; func (a *A) reset() &#123; a.Name = &quot;&quot; &#125; func Benchmark_A(b *testing.B) &#123; pool := &amp;sync.Pool&#123; New: func() interface&#123;&#125; &#123; return new(A) &#125;, &#125; pool2 := &amp;sync.Pool&#123; New: func() interface&#123;&#125; &#123; return new(A) &#125;, &#125; waitGroup := sync.WaitGroup&#123;&#125; waitGroup.Add(1) go func() &#123; defer waitGroup.Done() for i := 0; i &lt; b.N; i++ &#123; a := pool.Get().(*A) //a.reset() // 方式2 没有问题 if a.Name != &quot;&quot; &#123; panic(&quot;name not empty&quot;) &#125; a.putValue(i) // a.Name = &quot;A+&quot; + strconv.Itoa(i) if a.Name == &quot;&quot; &#123; panic(&quot;name is empty&quot;) &#125; a.reset() // 方式1 有问题的方式 pool.Put(a) &#125; &#125;() waitGroup.Add(1) go func() &#123; defer waitGroup.Done() for i := 0; i &lt; b.N; i++ &#123; a := pool.Get().(*A) a.reset() if a.Name != &quot;&quot; &#123; panic(&quot;name not empty&quot;) &#125; a.putValue(i) if a.Name == &quot;&quot; &#123; panic(&quot;name not empty&quot;) &#125; pool.Put(a) &#125; &#125;() waitGroup.Wait() &#125; 修改点 func (pool *taskPool) get() *Task &#123; task := pool.bp.Get().(*Task) task.Reset() return task &#125; func (pool *taskPool) put(obj *Task) &#123; pool.bp.Put(obj) &#125; 执行用例 BenchmarkTimeWheel ➜ go-timewheel (master) ✗ go test -v -bench . -test.bench=&#39;TimeWheel$&#39; -test.run ^$ goos: darwin goarch: amd64 pkg: github.com/rfyiamcool/go-timewheel cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz BenchmarkAdd-12 1990670 1090 ns/op BenchmarkTimeWheel/wheel-N-1m-12 1000000 1049 ns/op BenchmarkTimeWheel/wheel-N-5m-12 1223064 1061 ns/op BenchmarkTimeWheel/wheel-N-10m-12 1000000 1253 ns/op PASS ok github.com/rfyiamcool/go-timewheel 100.504s 问题点 task.callback 有值，但是 task.callback == nil 分支却执行了，断点在 task.callback() 时去执行 task.callback 确实是有值的 Task.stop = true","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"concurrent","slug":"concurrent","permalink":"https://huangxingx.github.io/tags/concurrent/"},{"name":"sync.Pool","slug":"sync-Pool","permalink":"https://huangxingx.github.io/tags/sync-Pool/"}]},{"title":"时间轮","slug":"算法/时间轮","date":"2021-09-30T01:45:10.000Z","updated":"2022-10-31T09:40:57.114Z","comments":true,"path":"2021/09/30/算法/时间轮/","link":"","permalink":"https://huangxingx.github.io/2021/09/30/%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E8%BD%AE/","excerpt":"","text":"时间轮 Timewheelkafka 时间轮的实现Kafka Timer 实现源码 Kafka 的层级时间轮实现中，利用了 Java 内置的 DelayQueue 结构，将每一层时间轮中所有 “包含有定时任务的 bucket” 都加入到同一个 DelayQueue 中，然后 等到有 bucket 到期后再驱动时钟往前走，并逐个处理该 bucket 中的定时任务 往层级时间轮中添加一个定时任务 task1 后，会将该任务所属的 bucket2 的到期时间设置为 task1 的到期时间 expiration（= 当前时间 currentTime + 定时任务到期间隔 duration），并将这个 bucket2 添加（Offer）到 DelayQueue 中。 DelayQueue（内部有一个线程）会等待 “到期时间最早（earliest）的 bucket” 到期，图中等到的是排在队首的 bucket2，于是经由 poll 返回并删除这个 bucket2；随后，时间轮会将当前时间 currentTime 往前移动到 bucket2 的 expiration 所指向的时间（图中是 1ms 所在的位置）；最后，bucket2 中包含的 task1 会被删除并执行。 Golang timewheel 实现参考 Kafka 时间轮实现的 golang 版本timewheel : https://github.com/RussellLuo/timingwheel.git PriorityQueue —— 从 NSQ 借用过来的 优先级队列（基于最小堆实现）。 DelayQueue —— Offer（添加 bucket）和 Poll（获取并删除 bucket）的运作方式，跟 Golang Timer 运行时中 addtimerLocked 和 timerproc 的运作方式如出一辙，因此参考了其中的实现方式（参考 原理介绍）。 基于 Timer 的版本go-timewhee : https://github.com/rfyiamcool/go-timewheel 参考： 层级时间轮的 Golang 实现","categories":[{"name":"算法","slug":"算法","permalink":"https://huangxingx.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://huangxingx.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"timewheels","slug":"timewheels","permalink":"https://huangxingx.github.io/tags/timewheels/"}]},{"title":"golang 实现计算器","slug":"golang/golang-实现计算器","date":"2021-09-24T08:58:16.000Z","updated":"2022-10-31T09:40:57.108Z","comments":true,"path":"2021/09/24/golang/golang-实现计算器/","link":"","permalink":"https://huangxingx.github.io/2021/09/24/golang/golang-%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"golang 实现一个计算的功能，并支持括号计算 github地址：https://github.com/huangxingx/go-utils.git 实现重点：后缀表达式一般的表达式都是中缀表达式，操作符在两个操作项之间。而后缀表达式的操作符在两个操作项后面 后缀表达式的实现利用栈 stack 和队列 queue 实现后缀表达式 流程： 先把字符串转换为列表 比如 “1+2+3*4” 转换为 [“1”, “+”, “2”, “+”, “3”, “*”, “4”] 上面的字符串列表转换为后缀表达式 遍历后缀表达式进行计算 computer.go package go_utils import &quot;strconv&quot; // Computer 计算后缀表达式 func Computer(expression string) float64 &#123; mpnExpression := parse2mpn(expression) rpnExpression := parse2rpn(mpnExpression) resultStack := NewStack() for _, v := range rpnExpression &#123; switch v &#123; case &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;: v1, _ := resultStack.Pop().(float64) v2, _ := resultStack.Pop().(float64) switch v &#123; case &quot;+&quot;: resultStack.Push(v1 + v2) case &quot;-&quot;: resultStack.Push(v2 - v1) case &quot;*&quot;: resultStack.Push(v2 * v1) case &quot;/&quot;: resultStack.Push(v2 / v1) &#125; default: float, err := strconv.ParseFloat(v, 64) if err != nil &#123; panic(err) &#125; resultStack.Push(float) &#125; &#125; return resultStack.Pop().(float64) &#125; // 解析中缀表达式数组 func parse2mpn(express string) []string &#123; //compile, _ := regexp.Compile(&quot;[\\\\d\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]&quot;) //return compile.FindAllString(express, -1) result := make([]string, 0) s := &quot;&quot; for i, v := range express &#123; if v == 32 &#123; continue &#125; if v &gt; 47 &amp;&amp; v &lt; 59 || v == 46 &#123; s += string(v) if i == len(express)-1 &#123; result = append(result, s) &#125; &#125; else &#123; // +-*/ ( ) if s != &quot;&quot; &#123; result = append(result, s) s = &quot;&quot; &#125; result = append(result, string(v)) &#125; &#125; return result &#125; // parse2rpn 解析中缀表达式-&gt; 后缀表达式 func parse2rpn(express []string) []string &#123; stact := NewStack() rpnList := make([]string, 0, len(express)) var s string for i := 0; i &lt; len(express); i++ &#123; s = express[i] switch s &#123; case &quot;+&quot;, &quot;-&quot;: for &#123; if stact.IsEmpty() || stact.Peek().(string) == &quot;(&quot; &#123; stact.Push(s) break &#125; else &#123; rpnList = append(rpnList, stact.Pop().(string)) &#125; &#125; case &quot;*&quot;, &quot;/&quot;: for &#123; if stact.IsEmpty() || (stact.Peek().(string) != &quot;*&quot; &amp;&amp; stact.Peek().(string) != &quot;/&quot;) &#123; stact.Push(s) break &#125; else &#123; rpnList = append(rpnList, stact.Pop().(string)) &#125; &#125; case &quot;(&quot;: stact.Push(s) case &quot;)&quot;: for stact.Peek().(string) != &quot;(&quot; &#123; rpnList = append(rpnList, stact.Pop().(string)) &#125; stact.Pop() default: rpnList = append(rpnList, s) &#125; &#125; for stact.Size() &gt; 0 &#123; rpnList = append(rpnList, stact.Pop().(string)) &#125; return rpnList &#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"算法","slug":"算法","permalink":"https://huangxingx.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"状态机","slug":"其他/状态机","date":"2021-09-23T09:49:33.000Z","updated":"2022-11-01T02:41:03.859Z","comments":true,"path":"2021/09/23/其他/状态机/","link":"","permalink":"https://huangxingx.github.io/2021/09/23/%E5%85%B6%E4%BB%96/%E7%8A%B6%E6%80%81%E6%9C%BA/","excerpt":"","text":"状态模式概念有限状态机（Finite State Machine）：有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。有 3 个组成部分：状态（State）、事件（Event）、动作（Action），事件触发状态的转移及动作的执行。 状态模式： 用来实现状态机的设计模式，常用在工作流引擎、工单等涉及到很多状态的场景。 作用状态模式能解耦状态和状态转移（事件），让整个状态机系统逻辑能加清晰。 todo 代码示例（订单状态转换） 状态转换图","categories":[{"name":"其他","slug":"其他","permalink":"https://huangxingx.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"golang ants 协程池","slug":"golang/golang-ants-协程池","date":"2021-09-18T08:07:50.000Z","updated":"2022-10-31T09:40:57.107Z","comments":true,"path":"2021/09/18/golang/golang-ants-协程池/","link":"","permalink":"https://huangxingx.github.io/2021/09/18/golang/golang-ants-%E5%8D%8F%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"ants 类图","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"ants","slug":"ants","permalink":"https://huangxingx.github.io/tags/ants/"},{"name":"goroutine","slug":"goroutine","permalink":"https://huangxingx.github.io/tags/goroutine/"}]},{"title":"jetbrains 插件推荐","slug":"其他/jetbrains-插件推荐","date":"2021-09-18T06:07:20.000Z","updated":"2022-11-01T03:10:44.745Z","comments":true,"path":"2021/09/18/其他/jetbrains-插件推荐/","link":"","permalink":"https://huangxingx.github.io/2021/09/18/%E5%85%B6%E4%BB%96/jetbrains-%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"","text":"PlantUML integration插件地址： https://plugins.jetbrains.com/plugin/7017-plantuml-integration PlantUML diagramming tool integration. Now better and faster, with code navigation and highlighting. CamelCase插件地址： https://plugins.jetbrains.com/plugin/7160-camelcase Switch easily between kebab-case, SNAKE_CASE, PascalCase, camelCase, snake_case or space case. See Edit menu or use ⇧ + ⌥ + U / Shift + Alt + U. Allows to disable some conversions or change their order in the preferences. GitToolBox插件地址：https://plugins.jetbrains.com/plugin/7499-gittoolbox Extends Git Integration with additional features Status display, auto fetch, inline blame annotation, commit dialog completion, behind notifications and more… For more see Manual TranslationTranslation plugin for IntelliJ based IDEs.","categories":[{"name":"其他","slug":"其他","permalink":"https://huangxingx.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"plugins","slug":"plugins","permalink":"https://huangxingx.github.io/tags/plugins/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://huangxingx.github.io/tags/jetbrains/"}]},{"title":"mysql 慢日志查询分析","slug":"mysql/mysql-慢日志查询分析","date":"2021-09-17T01:58:36.000Z","updated":"2022-10-31T09:40:57.112Z","comments":true,"path":"2021/09/17/mysql/mysql-慢日志查询分析/","link":"","permalink":"https://huangxingx.github.io/2021/09/17/mysql/mysql-%E6%85%A2%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/","excerpt":"","text":"慢查询日志相关参数 slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。 log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。 log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。 log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。 日志分析工具****mysqldumpslow在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow 查看mysqldumpslow的帮助信息： [root@DB-Server ~]# mysqldumpslow --help Usage: mysqldumpslow [ OPTS... ] [ LOGS... ] Parse and summarize the MySQL slow query log. Options are --verbose verbose --debug debug --help write this text to standard output -v verbose -d debug -s ORDER what to sort by (al, at, ar, c, l, r, t), &#39;at&#39; is default al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time -r reverse the sort order (largest last instead of first) -t NUM just show the top n queries -a don&#39;t abstract all numbers to N and strings to &#39;S&#39; -n NUM abstract numbers with at least n digits within names -g PATTERN grep: only consider stmts that include this string -h HOSTNAME hostname of db server for *-slow.log filename (can be wildcard), default is &#39;*&#39;, i.e. match all -i NAME name of server instance (if using mysql.server startup script) -l don&#39;t subtract lock time from total time -s, 是表示按照何种方式排序， c: 访问计数 l: 锁定时间 r: 返回记录 t: 查询时间 al:平均锁定时间 ar:平均返回记录数 at:平均查询时间 -t, 是top n的意思，即为返回前面多少条的数据； -g, 后边可以写一个正则匹配模式，大小写不敏感的； 比如 得到返回记录集最多的10个SQL。 mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log 得到访问次数最多的10个SQL mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log 得到按照时间排序的前10条里面含有左连接的查询语句。 mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。 mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more","categories":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/tags/mysql/"},{"name":"慢日志","slug":"慢日志","permalink":"https://huangxingx.github.io/tags/%E6%85%A2%E6%97%A5%E5%BF%97/"}]},{"title":"SQL中的in与not in、exists与not exists的区别以及性能分析","slug":"mysql/SQL中的in与not-in、exists与not-exists的区别以及性能分析","date":"2021-09-14T14:55:15.000Z","updated":"2022-11-01T02:43:31.312Z","comments":true,"path":"2021/09/14/mysql/SQL中的in与not-in、exists与not-exists的区别以及性能分析/","link":"","permalink":"https://huangxingx.github.io/2021/09/14/mysql/SQL%E4%B8%AD%E7%9A%84in%E4%B8%8Enot-in%E3%80%81exists%E4%B8%8Enot-exists%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","excerpt":"","text":"1、in和existsin是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询，一直以来认为exists比in效率高的说法是不准确的。 如果查询的两个表大小相当，那么用in和exists差别不大；如果两个表中一个较小一个较大，则子查询表大的用exists，子查询表小的用in； 2、not in 和not existsnot in 逻辑上不完全等同于not exists，如果你误用了not in，小心你的程序存在致命的BUG，请看下面的例子： create table #t1(c1 int,c2 int); create table #t2(c1 int,c2 int); insert into #t1 values(1,2); insert into #t1 values(1,3); insert into #t2 values(1,2); insert into #t2 values(1,null); select * from #t1 where c2 not in(select c2 from #t2); --&gt;执行结果：无 select * from #t1 where not exists(select 1 from #t2 where #t2.c2=#t1.c2) --&gt;执行结果：1 3 正如所看到的，not in出现了不期望的结果集，存在逻辑错误。如果看一下上述两个select 语句的执行计划，也会不同，后者使用了hash_aj，所以，请尽量不要使用not in(它会调用子查询)，而尽量使用not exists（它会调用关联子查询）。 如果子查询中返回的任意一条记录含有空值，则查询将不返回任何记录。如果子查询字段有非空限制，这时可以使用not in，并且可以通过提示让它用hasg_aj或merge_aj连接。 如果查询语句使用了not in，那么对内外表都进行全表扫描，没有用到索引；而not exists的子查询依然能用到表上的索引。所以无论哪个表大，用not exists都比not in 要快。 3、in 与 = 的区别select name from student where name in(&#39;zhang&#39;,&#39;wang&#39;,&#39;zhao&#39;); 与 select name from student where name=&#39;zhang&#39; or name=&#39;wang&#39; or name=&#39;zhao&#39; 的结果是相同的。 其他分析对于in 和 exists的性能区别: 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in,反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。 其实我们区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 对于not in 和 not exists的性能区别： not in 只有当子查询中，select 关键字后的字段有not null约束或者有这种暗示时用not in,另外如果主查询中表大，子查询中的表小但是记录多，则应当使用not in,并使用anti hash join. 如果主查询表中记录少，子查询表中记录多，并有索引，可以使用not exists,另外not in最好也可以用/*+ HASH_AJ */或者外连接+is null NOT IN 在基于成本的应用中较好","categories":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/categories/mysql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://huangxingx.github.io/tags/sql/"},{"name":"性能","slug":"性能","permalink":"https://huangxingx.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"springboot 事务","slug":"java/springboot-事务","date":"2021-09-13T12:18:56.000Z","updated":"2022-11-01T02:43:19.954Z","comments":true,"path":"2021/09/13/java/springboot-事务/","link":"","permalink":"https://huangxingx.github.io/2021/09/13/java/springboot-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"[toc] @Transactional 注解的属性介绍value 和 transactionManager 属性它们两个是一样的意思。当配置了多个事务管理器时，可以使用该属性指定选择哪个事务管理器。 propagation 属性事务的传播行为，默认值为 Propagation.REQUIRED。 REQUIRED 支持事务，如果业务方法执行时在一个事务中，则加入当前事务，否则则重新开始一个事务。 REQUIRES_NEW 支持事务。每次都是创建一个新事物，如果当前已经在事务中了，会挂起当前事务。 NESTED 支持事务。如果当前已经在一个事务中了，则嵌套在已有的事务中作为一个子事务。如果当前没在事务中则开启一个事务。 SUPPORTS 支持事务。当前有事务就加入当前事务。当前没有事务就算了，不会开启一个事物。 MANDATORY 支持事务，如果业务方法执行时已经在一个事务中，则加入当前事务。否则抛出异常。 NOT_SUPPORTED 不支持事务，如果业务方法执行时已经在一个事务中，则挂起当前事务，等方法执行完毕后，事务恢复进行。 NEVER 不支持事务。如果当前已经在一个事务中了，抛出异常。数据回滚。 isolation 属性事务的隔离级别，默认值为 Isolation.DEFAULT。 Isolation.DEFAULT 使用底层数据库默认的隔离级别。 Isolation.READ_UNCOMMITTED Isolation.READ_COMMITTED Isolation.REPEATABLE_READ Isolation.SERIALIZABLE timeout 属性事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。 readOnly 属性指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。 rollbackFor 属性用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。 noRollbackFor 属性抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。 事务不生效的情况1. 数据库不支持事物mysql 中 MyISAM 是不支持事物的。 2. 类内部访问简单来讲就是指非直接访问带注解标记的方法 B，而是通过类普通方法 A，然后由 A 访问 B 3. 私有方法在私有方法上，添加@Transactional注解也不会生效，私有方法外部不能访问，所以只能内部访问。 4. 异常不匹配@Transactional注解默认处理运行时异常，即只有抛出运行时异常时，才会触发事务回滚，否则并不会 5. 多线程这个场景可能并不多见，在标记事务的方法内部，另起子线程执行 db 操作，此时事务同样不会生效 6. 传播属性设置异常有些传播属性是不支持事物的，见上文中呢","categories":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://huangxingx.github.io/tags/springboot/"},{"name":"事务","slug":"事务","permalink":"https://huangxingx.github.io/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"uvicorn 初识","slug":"python/uvicorn-初识","date":"2021-09-09T09:10:23.000Z","updated":"2022-10-31T09:40:57.113Z","comments":true,"path":"2021/09/09/python/uvicorn-初识/","link":"","permalink":"https://huangxingx.github.io/2021/09/09/python/uvicorn-%E5%88%9D%E8%AF%86/","excerpt":"","text":"uvicorn简介uvicorn是一个基于asyncio开发的一个轻量级高效的web服务器框架。 官方地址： http://www.uvicorn.org/ uvicorn 设计的初衷是想要实现两个目标： 使用uvloop和httptools实现一个极速的asyncio服务器。 实现一个基于ASGI(异步服务器网关接口)的最小的应用程序接口。 它目前支持http，websockets，Pub/Sub 广播，并且可以扩展到其他协议和消息类型。","categories":[{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/tags/python/"},{"name":"web","slug":"web","permalink":"https://huangxingx.github.io/tags/web/"}]},{"title":"golang helloworld docker 启动","slug":"golang/golang-helloworld-docker-启动","date":"2021-09-08T09:15:43.000Z","updated":"2022-11-01T02:42:56.887Z","comments":true,"path":"2021/09/08/golang/golang-helloworld-docker-启动/","link":"","permalink":"https://huangxingx.github.io/2021/09/08/golang/golang-helloworld-docker-%E5%90%AF%E5%8A%A8/","excerpt":"","text":"golang的helloworld程序，利用docker-compose启动 创建项目目录并初始化go mod 项目 mkdir hellogo cd hellogo # 初始化 go mod 项目 go mod init hellogo 项目结构 ➜ hellogo tree . ├── docker-compose.yaml ├── dockerfile ├── go.mod └── main.go vim main.go package main import ( &quot;fmt&quot; &quot;time&quot; ) func main() &#123; fmt.Println(&quot;hello world&quot;) i := 1 for &#123; time.Sleep(1 * time.Second) fmt.Printf(&quot;wait %d second\\n&quot;, i) i++ &#125; &#125; vim dockerfile # build stage FROM golang:alpine AS builder RUN apk add --no-cache git gcc libc-dev RUN mkdir /app COPY go.mod /app/go.mod COPY main.go /app/main.go WORKDIR /app RUN go mod tidy RUN go build -o hellogo main.go # final stage FROM alpine:latest LABEL Name=hellogo Version=0.0.1 RUN apk --no-cache add ca-certificates COPY --from=builder /app/hellogo /app ENTRYPOINT ./app # EXPOSE 80 vim docker-compose.yaml version: &quot;3&quot; services: hellogo: build: . image: hellogo network_mode: bridge container_name: hellogo 运行 docker-compose docker-compose -f docker-compose.yaml up --build 看到如下输出表示成功 ... Successfully built 50cb8339209e Successfully tagged hellogo:latest Starting hellogo ... done Attaching to hellogo hellogo | hello world hellogo | wait 1 second hellogo | wait 2 second hellogo | wait 3 second","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://huangxingx.github.io/tags/docker/"},{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://huangxingx.github.io/tags/docker-compose/"},{"name":"helloworld","slug":"helloworld","permalink":"https://huangxingx.github.io/tags/helloworld/"}]},{"title":"git 常用命令","slug":"git/git-常用命令","date":"2021-09-08T07:43:04.000Z","updated":"2022-10-31T09:40:57.105Z","comments":true,"path":"2021/09/08/git/git-常用命令/","link":"","permalink":"https://huangxingx.github.io/2021/09/08/git/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git pull git push git checkout # 切换分支到本地 develop 分支 git checkout develop # 从当前分支新建一个分支 develop，并切换到 develop 分支 git checkout -b develop git status git log git stash git branch git rebase # 变基到两个提交之前 git rebase -i HEAD~2 git submodule # 所有子模块执行 git reset --hard git submodule foreach --recursive git reset --hard # 更新子模块 git submodule update --init git submodule update --remote","categories":[{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/tags/git/"}]},{"title":"redis 详解","slug":"redis/redis-详解","date":"2021-09-08T07:22:26.000Z","updated":"2022-11-01T02:43:46.905Z","comments":true,"path":"2021/09/08/redis/redis-详解/","link":"","permalink":"https://huangxingx.github.io/2021/09/08/redis/redis-%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"[toc] redis 介绍官网地址：https://redis.io/ Redis的全称是 REmote DIctionary Server，是一个高效的内存键值数据库，常被用来做分布式的高速缓存，相比较我们常规使用的Mysql、MongoDB等数据库，Redis的最大特点在于数据读写全部在内存中进行，进而带来极大的效率优势。 redis 使用场景 作为缓存服务器（String, Hash） 作为消息队列（List） 数据排行榜（Sorted Set） 热点数据 计数器； 比如统计点击率、点赞率，Redis具有原子性，可以避免并发问题。 以前只列出简单且常见的用途 redis 数据类型String、List、Hash、Set、Sorted Set 五种数据类型 StringString和我们常规理解的字符串基本一致，主要存储序列化后的字符串，支持写入原生字符串也支持写入数字类型。 ListList即为列表，List在Redis底层采用的是双向链表实现的，所以我们会发现Redis的List操作命令有左右之分，比如LPUSH、RPUSH，实际上就是双端列表左右两端的存取。 HashHash可以理解为我们常规使用的字典数据结构，Redis采用散列表来实现Hash， 一个Hash结构里面可以存在很多的key和value，Hash是Redis比较推荐使用的一种数据结构 SetSet是集合，满足集合确定性、无序性、唯一性三个性质，可以用来进行元素的去重操作 Sorted SetSorted Set是有序集合，满足集合唯一性的要求，同时也满足有序的性质。向Sorted Set中插入元素的时候需要同时指定一个Score，用于作为排序的标准， Sorted Set的底层实现采用的是Skip List redis 命令 参考： Redis详解（1）——为什么我们都需要了解Redis","categories":[{"name":"redis","slug":"redis","permalink":"https://huangxingx.github.io/categories/redis/"}],"tags":[]},{"title":"golang 启动一个简单 http 代理","slug":"golang/golang 启动一个简单 http 代理","date":"2020-05-08T03:30:57.000Z","updated":"2022-10-31T09:40:57.106Z","comments":true,"path":"2020/05/08/golang/golang 启动一个简单 http 代理/","link":"","permalink":"https://huangxingx.github.io/2020/05/08/golang/golang%20%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%20http%20%E4%BB%A3%E7%90%86/","excerpt":"","text":"golang 转发 http 请求package main import ( &quot;log&quot; &quot;net/http&quot; &quot;net/http/httputil&quot; &quot;net/url&quot; ) //将request转发给 http://127.0.0.1:2003 func proxyHandler(w http.ResponseWriter, r *http.Request) &#123; trueServer := &quot;http://127.0.0.1:15672&quot; url, err := url.Parse(trueServer) if err != nil &#123; log.Println(err) return &#125; proxy := httputil.NewSingleHostReverseProxy(url) proxy.ServeHTTP(w, r) &#125; func main() &#123; http.HandleFunc(&quot;/&quot;, proxyHandler) log.Fatal(http.ListenAndServe(&quot;:2002&quot;, nil)) &#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"http","slug":"http","permalink":"https://huangxingx.github.io/tags/http/"}]},{"title":"go-micro 使用问题记录","slug":"golang/go-micro 使用问题记录","date":"2019-11-05T10:30:57.000Z","updated":"2022-11-01T02:42:47.276Z","comments":true,"path":"2019/11/05/golang/go-micro 使用问题记录/","link":"","permalink":"https://huangxingx.github.io/2019/11/05/golang/go-micro%20%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. &#109;&#x69;&#99;&#x72;&#x6f;&#64;&#118;&#49;&#x2e;&#49;&#52; 之后使用 consul 作为注册中心问题&#x6d;&#x69;&#99;&#x72;&#111;&#x40;&#x76;&#x31;&#46;&#49;&#x34; 之后更换了默认的注册中心，把 consul 换成了 etcd ，如果需要使用 consul 作为注册中心，需要重新编译 micro。 clone 源码： git clone https://github.com/micro/micro.git 切到源码目录并新增 plugins.go : cd micro源码目录 vi plugins.go package main import ( _ &quot;github.com/micro/go-plugins/registry/consul&quot; ) 编译 go build -o mainWithConsul main.go plugins.go 运行 ./mainWithConsul --registry=consul api 2. micro 用 gin 作为 api 问题用 gin 做为 gin-api 服务时， 通过 micro new –type web 创建一个服务出来，注意修改服务的 name，改为 com.example.api.ServiceName,且在 gin router 中创建： router := gin.Default() r := router.Group(&quot;/ServiceName&quot;) micro api --namespace=com.example.api 启动 这里必须要加 api 不然转发不了 3. 使用 micro new 生成模板使用 micro new 生成模板， RegisterSubscriber 的 topic 名称和 service name 一样，导致大概50%的概率出现请求失败问题. 解决方法: 注释 RegisterSubscriber 部分代码，或者换一个 topic 名称。","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"go-micro","slug":"go-micro","permalink":"https://huangxingx.github.io/tags/go-micro/"},{"name":"微服务","slug":"微服务","permalink":"https://huangxingx.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"注意事项","slug":"注意事项","permalink":"https://huangxingx.github.io/tags/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"}]},{"title":"golang 生成随机字符串","slug":"golang/golang 生成随机字符串","date":"2019-06-13T07:41:22.000Z","updated":"2022-10-31T09:00:20.493Z","comments":true,"path":"2019/06/13/golang/golang 生成随机字符串/","link":"","permalink":"https://huangxingx.github.io/2019/06/13/golang/golang%20%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"随机字符串 //RandomStr 随机生成字符串 func RandomStr(length int) string &#123; str := &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; bytes := []byte(str) result := []byte&#123;&#125; r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; length; i++ &#123; result = append(result, bytes[r.Intn(len(bytes))]) &#125; return string(result) &#125; 生成定长字符串//获得定长字符串 //str 填充字符串 //length 获得定长的长度 //char 不够长时填充的字符 func GetFixedLenString(str string, length int, char byte) string &#123; if len(str) == 0 &#123; return &quot;&quot; &#125; if len(str) == length &#123; return str &#125; //超出切后面 if len(str) &gt; length &#123; return string(str[:length]) &#125; //缺少添加char if len(str) &lt; length &#123; slice := make([]byte, length-len(str)) for k := range slice &#123; slice[k] = char &#125; return string(append(slice, []byte(str)...)) &#125; return &quot;&quot; &#125; 获得定长byte slice//获得定长byte slice //str 填充字符串 //length 获得定长的长度 //char 不够长时填充的字符 func GetFixedLenByte(b []byte, length int, char byte) (tb []byte) &#123; if len(b) == 0 &#123; return &#125; if len(b) == length &#123; return b &#125; //超出切后面 if len(b) &gt; length &#123; return b[:length] &#125; //缺少添加char if len(b) &lt; length &#123; slice := make([]byte, length-len(b)) for k := range slice &#123; slice[k] = char &#125; return append(slice, []byte(b)...) &#125; return &#125; 生成随机验证码package main import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;strings&quot; &quot;time&quot; ) func GenValidateCode(width int) string &#123; numeric := [10]byte&#123;0,1,2,3,4,5,6,7,8,9&#125; r := len(numeric) rand.Seed(time.Now().UnixNano()) var sb strings.Builder for i := 0; i &lt; width; i++ &#123; fmt.Fprintf(&amp;sb, &quot;%d&quot;, numeric[ rand.Intn(r) ]) &#125; return sb.String() &#125; func main() &#123; fmt.Println( GenValidateCode(6) ) &#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"}]},{"title":"mysql 距离函数 st_distance 使用","slug":"mysql/mysql 距离函数 st_distance 使用","date":"2019-06-12T07:58:59.000Z","updated":"2022-11-01T02:43:25.286Z","comments":true,"path":"2019/06/12/mysql/mysql 距离函数 st_distance 使用/","link":"","permalink":"https://huangxingx.github.io/2019/06/12/mysql/mysql%20%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0%20st_distance%20%E4%BD%BF%E7%94%A8/","excerpt":"","text":"随着近几年各类移动终端的迅速普及，在手机移动定位app中，附近的人，附近的地点功能十分常见,基于地理位置的服务（LBS）和相关应用也越来越多，而支撑这些应用的最基础技术之一，就是基于地理位置信息的处理。 st_distance 函数st_distance 函数是从mysql5.6.1才加入的。SET @g1 = POINT(1,1), @g2 = POINT(2,2);select st_distance (@g1, @g2);输出结果：1.4142135623730951 SELECT st_distance (point (1, 1),point(2,2) ) * 111195 // 输出结果：157253.47706807632 单位：米st_distance 计算的结果单位是度，需要乘111195（地球半径6371000*PI/180）是将值转化为米。 当然你也可以自定义距离函数： CREATE FUNCTION slc ( lat1 DOUBLE, lon1 DOUBLE, lat2 DOUBLE, lon2 DOUBLE ) RETURNS DOUBLE RETURN 6371 * acos( cos(radians(lat1)) * cos(radians(lat2)) * cos( radians(lon2) - radians(lon1) ) + sin(radians(lat1)) * sin(radians(lat2)) ); SELECT slc(1,1,2,2) from DUAL // 输出结果：157.22543203804852 km 应用场景:假设我当时的坐标 117.069,35.86 需要查询我附近50KM内服务区，并按照距离由近及远排列 SELECT s.id,s.name,s.lng,s.lat, (st_distance (point (lng, lat),point(117.069,35.86) ) *111195) AS distance FROM road_servicearea s HAVING distance&lt;50 ORDER BY distance 知识科普：地球是在不停地绕地轴旋转，在地球中腰画一个与地轴垂直的大圆圈，使圈上的每一点都和南北两极的距离相等，这个圆圈就叫作“赤道”。在赤道的南北两边，画出许多和赤道平行的圆圈，就是“纬圈”；构成这些圆圈的线段，叫做纬线。我们把赤道定为纬度零度，向南向北各为90度，在赤道以南的叫南纬，在赤道以北的叫北纬。北极就是北纬90度，南极就是南纬90度。纬度的高低也标志着气候的冷热，如赤道和低纬度地地区无冬，两极和高纬度地区无夏，中纬度地区四季分明。 从北极点到南极点，可以画出许多南北方向的与地球赤道垂直的大圆圈，这叫作“经圈”；构成这些圆圈的线段，就叫经线。公元1884平面坐标图年，国际上规定以通过英国伦敦近郊的格林尼治天文台的经线作为计算经度的起点，即经度零度零分零秒，也称“本初子午线”。在它东面的为东经，共180度； 在它西面的为西经，共180度。因为地球是圆的，所以东经180度和西经180度的经线是同一条经线。各国公定180度经线为“国际日期变更线”。为了避免同一地区使用两个不同的日期，国际日期变线在遇陆地时略有偏离。每一经度和纬度还可以再细分为60分，每一分再分为60秒以及秒的小数。利用经纬线，我们就可以确定地球上每一个地方的具体位置，并且把它在地图或地球仪上表示出来。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/tags/mysql/"},{"name":"function","slug":"function","permalink":"https://huangxingx.github.io/tags/function/"}]},{"title":"gorm 中使用 json","slug":"golang/gorm 中使用 json","date":"2019-06-11T08:55:56.000Z","updated":"2022-11-01T02:43:01.772Z","comments":true,"path":"2019/06/11/golang/gorm 中使用 json/","link":"","permalink":"https://huangxingx.github.io/2019/06/11/golang/gorm%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20json/","excerpt":"","text":"Json 类的实现package models import ( &quot;bytes&quot; &quot;database/sql/driver&quot; &quot;errors&quot; ) type JSON []byte func (j JSON) Value() (driver.Value, error) &#123; if j.IsNull() &#123; return nil, nil &#125; return string(j), nil &#125; func (j *JSON) Scan(value interface&#123;&#125;) error &#123; if value == nil &#123; *j = nil return nil &#125; s, ok := value.([]byte) if !ok &#123; errors.New(&quot;Invalid Scan Source&quot;) &#125; *j = append((*j)[0:0], s...) return nil &#125; func (m JSON) MarshalJSON() ([]byte, error) &#123; if m == nil &#123; return []byte(&quot;null&quot;), nil &#125; return m, nil &#125; func (m *JSON) UnmarshalJSON(data []byte) error &#123; if m == nil &#123; return errors.New(&quot;null point exception&quot;) &#125; *m = append((*m)[0:0], data...) return nil &#125; func (j JSON) IsNull() bool &#123; return len(j) == 0 || string(j) == &quot;null&quot; &#125; func (j JSON) Equals(j1 JSON) bool &#123; return bytes.Equal([]byte(j), []byte(j1)) &#125; 在自定义 Model 中使用 Json Typepackage models type Model struct &#123; ID int `gorm:&quot;primary_key&quot; json:&quot;id&quot;` CreatedAt int64 `json:&quot;createdAt&quot;` UpdatedAt int64 `json:&quot;updatedAt&quot;` Object JSON `sql:&quot;type:json&quot; json:&quot;object,omitempty&quot;` &#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"gorm","slug":"gorm","permalink":"https://huangxingx.github.io/tags/gorm/"}]},{"title":"golang future 实现","slug":"golang/golang future 实现","date":"2019-06-06T07:16:40.000Z","updated":"2022-10-31T09:40:57.106Z","comments":true,"path":"2019/06/06/golang/golang future 实现/","link":"","permalink":"https://huangxingx.github.io/2019/06/06/golang/golang%20future%20%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"实现如下 package utils import ( &quot;sync&quot; &quot;time&quot; ) // Future type Future struct &#123; isfinished bool result interface&#123;&#125; resultchan chan interface&#123;&#125; l sync.Mutex &#125; // GetResult get return value func (f *Future) GetResult() interface&#123;&#125; &#123; f.l.Lock() defer f.l.Unlock() if f.isfinished &#123; return f.result &#125; select &#123; // timeout case &lt;-time.Tick(time.Second * 6): f.isfinished = true f.result = nil return nil case f.result = &lt;-f.resultchan: f.isfinished = true return f.result &#125; &#125; // SetResult set return value func (f *Future) SetResult(result interface&#123;&#125;) &#123; if f.isfinished == true &#123; return &#125; f.resultchan &lt;- result close(f.resultchan) &#125; // NewFuture init Future func NewFuture() *Future &#123; return &amp;Future&#123; isfinished: false, result: nil, resultchan: make(chan interface&#123;&#125;, 1), &#125; &#125; 调用 /* Future 是一个未来的任务的抽象。和python里的那个有点类似。 在异步任务中SetResult，在GetResult的时候会等待result生成，或者超时。 */ tasks := make([]*utils.Future, 0) for i := 0; i &lt; 10; i++ &#123; future := utils.NewFuture() tasks = append(tasks, future) go func(result int) &#123; time.Sleep(time.Second * time.Duration(rand.Int63n(10))) future.SetResult(result) &#125;(i) &#125; for _, item := range tasks &#123; ret, ok := item.GetResult().(int) if ok &#123; fmt.Println(ret) &#125; else &#123; fmt.Println(&quot;failed&quot;) &#125; &#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"future","slug":"future","permalink":"https://huangxingx.github.io/tags/future/"}]},{"title":"markdown 语法简介","slug":"其他/markdown 语法简介","date":"2019-06-05T03:13:18.000Z","updated":"2022-11-01T02:41:19.882Z","comments":true,"path":"2019/06/05/其他/markdown 语法简介/","link":"","permalink":"https://huangxingx.github.io/2019/06/05/%E5%85%B6%E4%BB%96/markdown%20%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/","excerpt":"","text":"#一、标题写法： 第一种方法： 1、在文本下面加上 等于号 = ，那么上方的文本就变成了大标题。等于号的个数无限制，但一定要大于0个哦。。 2、在文本下面加上 下划线 - ，那么上方的文本就变成了中标题，同样的 下划线个数无限制。 3、要想输入=号，上面有文本而不让其转化为大标题，则需要在两者之间加一个空行。 另一种方法：（推荐这种方法；注意⚠️中间需要有一个空格） 关于标题还有等级表示法，分为六个等级，显示的文本大小依次减小。不同等级之间是以井号 # 的个数来标识的。一级标题有一个 #，二级标题有两个# ，以此类推。 例如： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 二、编辑基本语法 1、字体格式强调 我们可以使用下面的方式给我们的文本添加强调的效果 *强调* (示例：斜体) _强调_ (示例：斜体) **加重强调** (示例：粗体) __加重强调__ (示例：粗体) ***特别强调*** (示例：粗斜体) ___特别强调___ (示例：粗斜体) 2、代码 `&lt;hello world&gt;` 3、代码块高亮 (```) @Override protected void onDestroy() &#123; EventBus.getDefault().unregister(this); super.onDestroy(); &#125; (```) 4、表格 （建议在表格前空一行，否则可能影响表格无法显示） 表头 | 表头 | 表头 ---- | ----- | ------ 单元格内容 | 单元格内容 | 单元格内容 单元格内容 | 单元格内容 | 单元格内容 5、其他引用 图片 ![图片名称](https://www.baidu.com/img/bd_logo1.png) 链接 [链接名称](https://www.baidu.com/) 6、列表 1. 项目1 2. 项目2 3. 项目3 * 项目1 （一个*号会显示为一个黑点，注意⚠️有空格，否则直接显示为*项目1） * 项目2 7、换行（建议直接在前一行后面补两个空格） 直接回车不能换行， 可以在上一行文本后面补两个空格， 这样下一行的文本就换行了。 或者就是在两行文本直接加一个空行。 也能实现换行效果，不过这个行间距有点大。 8、引用 &gt; 第一行引用文字 &gt; 第二行引用文字","categories":[{"name":"其他","slug":"其他","permalink":"https://huangxingx.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://huangxingx.github.io/tags/markdown/"},{"name":"api","slug":"api","permalink":"https://huangxingx.github.io/tags/api/"}]},{"title":"网站收藏","slug":"其他/网站收藏","date":"2019-06-04T08:20:14.000Z","updated":"2022-11-01T02:40:51.532Z","comments":true,"path":"2019/06/04/其他/网站收藏/","link":"","permalink":"https://huangxingx.github.io/2019/06/04/%E5%85%B6%E4%BB%96/%E7%BD%91%E7%AB%99%E6%94%B6%E8%97%8F/","excerpt":"","text":"[toc] 官网hexo [https://hexo.io redis https://redis.io/ git https://git-scm.com/book/zh/v2 golang https://golang.google.cn/ uvicorn Python ASGI 框架 http://www.uvicorn.org/ API 网站hexo https://hexo.io/api/ redis https://redis.io markdown https://markdown.com.cn/ golang 第三方库ants 协程池 https://github.com/panjf2000/ants/ gorm orm https://gorm.io/zh_CN/ 工具网站excalidraw 在线作图 https://excalidraw.com/ oktools https://oktools.net/ json2go https://oktools.net/json2go processon 在线作图 https://www.processon.com/ 其他macwk Mac 软件下载 https://macwk.com/","categories":[{"name":"其他","slug":"其他","permalink":"https://huangxingx.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"api","slug":"api","permalink":"https://huangxingx.github.io/tags/api/"},{"name":"site","slug":"site","permalink":"https://huangxingx.github.io/tags/site/"}]},{"title":"http 状态码","slug":"其他/http 状态码","date":"2018-04-18T09:21:05.000Z","updated":"2018-04-18T09:21:05.000Z","comments":true,"path":"2018/04/18/其他/http 状态码/","link":"","permalink":"https://huangxingx.github.io/2018/04/18/%E5%85%B6%E4%BB%96/http%20%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"HTTP协议状态码表示的意思主要分为五类 ,大体是 : 1×× 保留 2×× 表示请求成功地接收 3×× 为完成请求客户需进一步细化请求 4×× 客户错误 5×× 服务器错误 100 Continue指示客户端应该继续请求。回送用于通知客户端此次请求已经收到，并且没有被服务器拒绝。客户端应该继续发送剩下的请求数据或者请求已经完成，或者忽略回送数据。服务器必须发送最后的回送在请求之后。 101 Switching Protocols服务器依照客服端请求，通过Upgrade头信息，改变当前连接的应用协议。服务器将根据Upgrade头立刻改变协议 在101回送以空行结束的时候。 Successful200 OK指示客服端的请求已经成功收到，解析，接受。 201 Created请求已经完成并一个新的返回资源被创建。被创建的资源可能是一个URI资源，通常URI资源在Location头指定。回送应该包含一个实体数据并且包含资源特性以及location通过用户或者用户代理来选择合适的方法。实体数据格式通过煤体类型来指定即content-type头。最开始服务 器必须创建指定的资源在返回201状态码之前。如果行为没有被立刻执行，服务器应该返回202。 202 Accepted请求已经被接受用来处理。但是处理并没有完成。请求可能或者根本没有遵照执行，因为处理实际执行过程中可能被拒绝。 203 Non-Authoritative Information不是权威性信息。 204 No Content服务器已经接受请求并且没必要返回实体数据，可能需要返回更新信息。回送可能包含新的或更新信息由entity-headers呈现。 205 Reset Content服务器已经接受请求并且用户代理应该重新设置文档视图。 206 Partial Content服务器已经接受请求GET请求资源的部分。请求必须包含一个Range头信息以指示获取范围可能必须包含If-Range头信息以成立请求条件。 Redirection300 Multiple Choices请求资源符合任何一个呈现方式。 301 Moved Permanently请求的资源已经被赋予一个新的URI。 302 Found通过不同的URI请求资源的临时文件。 303 See Other304 Not Modified如果客服端已经完成一个有条件的请求并且请求是允许的，但是这个文档并没有改变，服务器应该返回304状态码。304状态码一定不能包含信息主体，从而通常通过一个头字段后的第一个空行结束。 305 Use Proxy请求的资源必须通过代理（由Location字段指定）来访问。Location资源给出了代理的URI。 306 Unused307 Temporary Redirect临时重定向。 Client Error400 Bad Request因为错误的语法导致服务器无法理解请求信息。 401 Unauthorized如果请求需要用户验证。回送应该包含一个WWW-Authenticate头字段用来指明请求资源的权限。 402 Payment Required保留状态码。 403 Forbidden服务器接受请求，但是被拒绝处理。 404 Not Found服务器已经找到任何匹配Request-URI的资源。 405 Menthod Not AllowedRequest-Line 请求的方法不被允许通过指定的URI。 406 Not Acceptable客户端浏览器不接受所请求页面的 MIME 类型。 407 Proxy Authentication Required要求进行代理身份验证。 408 Reqeust Timeout客服端没有提交任何请求在服务器等待处理时间内。 409 Conflict410 Gone411 Length Required服务器拒绝接受请求在没有定义Content-Length字段的情况下。 412 Precondition Failed前提条件失败。 413 Request Entity Too Large服务器拒绝处理请求因为请求数据超过服务器能够处理的范围。服务器可能关闭当前连接来阻止客服端继续请求。 414 Request-URI Too Long服务器拒绝服务当前请求因为URI的长度超过了服务器的解析范围。 415 Unsupported Media Type服务器拒绝服务当前请求因为请求数据格式并不被请求的资源支持。 416 Request Range Not Satisfialbe所请求的范围无法满足。 417 Expectation Failed执行失败。 Server Error500 Internal Server Error服务器遭遇异常阻止了当前请求的执行 501 Not Implemented服务器没有相应的执行动作来完成当前请求。 502 Bad GatewayWeb 服务器用作网关或代理服务器时收到了无效响应。 503 Service Unavailable因为临时文件超载导致服务器不能处理当前请求。 504 Gateway Timeout网关访问超时。 505 Http Version Not SupportedHTTP 版本不受支持。 &quot;100&quot; : Continue &quot;101&quot; : witching Protocols &quot;200&quot; : OK &quot;201&quot; : Created &quot;202&quot; : Accepted &quot;203&quot; : Non-Authoritative Information &quot;204&quot; : No Content &quot;205&quot; : Reset Content &quot;206&quot; : Partial Content &quot;300&quot; : Multiple Choices &quot;301&quot; : Moved Permanently &quot;302&quot; : Found &quot;303&quot; : See Other &quot;304&quot; : Not Modified &quot;305&quot; : Use Proxy &quot;307&quot; : Temporary Redirect &quot;400&quot; : Bad Request &quot;401&quot; : Unauthorized &quot;402&quot; : Payment Required &quot;403&quot; : Forbidden &quot;404&quot; : Not Found &quot;405&quot; : Method Not Allowed &quot;406&quot; : Not Acceptable &quot;407&quot; : Proxy Authentication Required &quot;408&quot; : Request Time-out &quot;409&quot; : Conflict &quot;410&quot; : Gone &quot;411&quot; : Length Required &quot;412&quot; : Precondition Failed &quot;413&quot; : Request Entity Too Large &quot;414&quot; : Request-URI Too Large &quot;415&quot; : Unsupported Media Type &quot;416&quot; : Requested range not satisfiable &quot;417&quot; : Expectation Failed &quot;500&quot; : Internal Server Error &quot;501&quot; : Not Implemented &quot;502&quot; : Bad Gateway &quot;503&quot; : Service Unavailable &quot;504&quot; : Gateway Time-out &quot;505&quot; : HTTP Version not supported","categories":[{"name":"其他","slug":"其他","permalink":"https://huangxingx.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"http","slug":"http","permalink":"https://huangxingx.github.io/tags/http/"},{"name":"web","slug":"web","permalink":"https://huangxingx.github.io/tags/web/"}]},{"title":"python 正则表达式简介","slug":"python/python 正则表达式简介","date":"2017-11-13T09:21:05.000Z","updated":"2022-11-01T02:43:38.057Z","comments":true,"path":"2017/11/13/python/python 正则表达式简介/","link":"","permalink":"https://huangxingx.github.io/2017/11/13/python/python%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1. 概念：正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。使用这个小型语言， 你可以为想要匹配的相应字符串集指定规则；该字符串集可能包含英文语句、email 地址、TeX命令或任何你想搞定的东西。然后你可以问诸如“这个字符串匹配该模式吗？”或“在这个字符串中是否有部分匹配该模式呢？”。你也可以使用 RE 以各种方式来修改或分割字符串。 2. 在正则表达式中， 如下的字符是具有特殊含义的. (所有字符) ^ $ *(0-N次) +(1-N次) ? (0-1次) &#123; &#125; [ ] \\ | ( ) 1).&quot;[&quot; 和 &quot;]&quot;。它们常用来指定一个字符类别，所谓字符类别就是你想匹配的一个字符集 2).其它地方的&quot;^&quot;只会简单匹配 &quot;^&quot;字符本身。例[^5] 将匹配除 &quot;5&quot; 之外的任意字符。 3).反斜杠后面可以加不同的字符以表示不同特殊意义。它也可以用于取消所有的元字符 3. RE 函数用法: findall(rule , target [,flag] ) 在目标字符串中查找符合规则的字符串。 match() 决定 RE 是否在字符串刚开始的位置匹配 search() 扫描字符串，找到这个 RE 匹配的位置 findall() 找到 RE 匹配的所有子串，并把它们作为一个列表返回 finditer() 找到 RE 匹配的所有子串，并把它们作为一个迭代器返回 group() 返回被 RE 匹配的字符串 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 compile( rule [,flag] )将正则规则编译成一个Pattern对象，以供接下来使用第一个参数是规则式，第二个参数是规则选项。(使用compile加速) 4. 含义:预定义转义字符集： “\\d” “\\w” “\\s” 等等，它们是以字符’\\’开头，后面接一个特定 字符的形式,用来指示一个预定义好的含义 ‘^’ 和’$’ 匹配字符串开头和结尾 ‘.’ 匹配所有字符 除\\n以外 ‘\\d’ 匹配数字 ‘\\D’ 匹配非数字 ‘\\w’ 匹配字母和数字 ‘\\W’ 匹配非英文字母和数字 ‘\\s’ 匹配间隔符 ‘\\S’ 匹配非间隔符 ‘\\A’ 匹配字符串开头 ‘\\Z’ 匹配字符串结尾 ‘\\b’ 只用以匹配单词的词首和词尾。单词被定义为一个字母数字序列，因此词尾就是用空白符或非字母数字符来标示的。(退格) ‘\\B’，它正好同 \\b 相反，只在当前位置不在单词边界时匹配。 5. 前向界定与后向界定: ‘(?&lt;=…)’ 前向界定:括号中’…’代表你希望匹配的字符串的前面应该出现的字符串。 ‘(?=…)’后向界定 :括号中的’…’代表你希望匹配的字符串后面应该出现的字符串 ‘(?&lt;!..)’前向非界定 :只有当你希望的字符串前面不是’…’的内容时才匹配 ‘(?!...)’后向非界定 :只有当你希望的字符串后面不跟着’…’内容时才匹配。 6. 组的基本知识: ‘(‘’)’ 无命名组 [a-z]+(\\d+)[a-z]+ ‘(?P&lt;name&gt;…)’ 命名组 (?P&lt;g1&gt;[a-z]+)\\d+(?P=g1) ‘(?P=name)’ 调用已匹配的命名组 ‘\\number’ 通过序号调用已匹配的组正则式中的每个组都有一个序号，序号是按组从左到右，从1开始的数字，你可以通过下面的形式来调用已匹配的组 ( r&quot;(\\d+)([a-z]+)(\\d+)(\\2)(\\1)&quot; )","categories":[{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/categories/python/"}],"tags":[{"name":"regex","slug":"regex","permalink":"https://huangxingx.github.io/tags/regex/"},{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/tags/python/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/categories/java/"},{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/categories/git/"},{"name":"docker","slug":"docker","permalink":"https://huangxingx.github.io/categories/docker/"},{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/categories/golang/"},{"name":"mac","slug":"mac","permalink":"https://huangxingx.github.io/categories/mac/"},{"name":"linux","slug":"linux","permalink":"https://huangxingx.github.io/categories/linux/"},{"name":"算法","slug":"算法","permalink":"https://huangxingx.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"其他","slug":"其他","permalink":"https://huangxingx.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/categories/mysql/"},{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/categories/python/"},{"name":"redis","slug":"redis","permalink":"https://huangxingx.github.io/categories/redis/"}],"tags":[{"name":"java","slug":"java","permalink":"https://huangxingx.github.io/tags/java/"},{"name":"git","slug":"git","permalink":"https://huangxingx.github.io/tags/git/"},{"name":"docker","slug":"docker","permalink":"https://huangxingx.github.io/tags/docker/"},{"name":"golang","slug":"golang","permalink":"https://huangxingx.github.io/tags/golang/"},{"name":"gin","slug":"gin","permalink":"https://huangxingx.github.io/tags/gin/"},{"name":"regex","slug":"regex","permalink":"https://huangxingx.github.io/tags/regex/"},{"name":"mac","slug":"mac","permalink":"https://huangxingx.github.io/tags/mac/"},{"name":"ssh","slug":"ssh","permalink":"https://huangxingx.github.io/tags/ssh/"},{"name":"linux","slug":"linux","permalink":"https://huangxingx.github.io/tags/linux/"},{"name":"maven","slug":"maven","permalink":"https://huangxingx.github.io/tags/maven/"},{"name":"mapstruct","slug":"mapstruct","permalink":"https://huangxingx.github.io/tags/mapstruct/"},{"name":"plugins","slug":"plugins","permalink":"https://huangxingx.github.io/tags/plugins/"},{"name":"concurrent","slug":"concurrent","permalink":"https://huangxingx.github.io/tags/concurrent/"},{"name":"sync.Pool","slug":"sync-Pool","permalink":"https://huangxingx.github.io/tags/sync-Pool/"},{"name":"算法","slug":"算法","permalink":"https://huangxingx.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"timewheels","slug":"timewheels","permalink":"https://huangxingx.github.io/tags/timewheels/"},{"name":"ants","slug":"ants","permalink":"https://huangxingx.github.io/tags/ants/"},{"name":"goroutine","slug":"goroutine","permalink":"https://huangxingx.github.io/tags/goroutine/"},{"name":"jetbrains","slug":"jetbrains","permalink":"https://huangxingx.github.io/tags/jetbrains/"},{"name":"mysql","slug":"mysql","permalink":"https://huangxingx.github.io/tags/mysql/"},{"name":"慢日志","slug":"慢日志","permalink":"https://huangxingx.github.io/tags/%E6%85%A2%E6%97%A5%E5%BF%97/"},{"name":"sql","slug":"sql","permalink":"https://huangxingx.github.io/tags/sql/"},{"name":"性能","slug":"性能","permalink":"https://huangxingx.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"springboot","slug":"springboot","permalink":"https://huangxingx.github.io/tags/springboot/"},{"name":"事务","slug":"事务","permalink":"https://huangxingx.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"python","slug":"python","permalink":"https://huangxingx.github.io/tags/python/"},{"name":"web","slug":"web","permalink":"https://huangxingx.github.io/tags/web/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://huangxingx.github.io/tags/docker-compose/"},{"name":"helloworld","slug":"helloworld","permalink":"https://huangxingx.github.io/tags/helloworld/"},{"name":"http","slug":"http","permalink":"https://huangxingx.github.io/tags/http/"},{"name":"go-micro","slug":"go-micro","permalink":"https://huangxingx.github.io/tags/go-micro/"},{"name":"微服务","slug":"微服务","permalink":"https://huangxingx.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"注意事项","slug":"注意事项","permalink":"https://huangxingx.github.io/tags/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"name":"function","slug":"function","permalink":"https://huangxingx.github.io/tags/function/"},{"name":"gorm","slug":"gorm","permalink":"https://huangxingx.github.io/tags/gorm/"},{"name":"future","slug":"future","permalink":"https://huangxingx.github.io/tags/future/"},{"name":"markdown","slug":"markdown","permalink":"https://huangxingx.github.io/tags/markdown/"},{"name":"api","slug":"api","permalink":"https://huangxingx.github.io/tags/api/"},{"name":"site","slug":"site","permalink":"https://huangxingx.github.io/tags/site/"}]}